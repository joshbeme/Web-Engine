# [doc = r" Error types."] pub mod error { # [doc = r" Error from a `TryFrom` or `FromStr` implementation."] pub struct ConversionError (:: std :: borrow :: Cow < 'static , str >) ; impl :: std :: error :: Error for ConversionError { } impl :: std :: fmt :: Display for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Display :: fmt (& self . 0 , f) } } impl :: std :: fmt :: Debug for ConversionError { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> Result < () , :: std :: fmt :: Error > { :: std :: fmt :: Debug :: fmt (& self . 0 , f) } } impl From < & 'static str > for ConversionError { fn from (value : & 'static str) -> Self { Self (value . into ()) } } impl From < String > for ConversionError { fn from (value : String) -> Self { Self (value . into ()) } } } # [doc = "`AppState`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"title\": \"AppState\","] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"config\","] # [doc = "    \"user\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"config\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"notificationsEnabled\","] # [doc = "        \"theme\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"theme\": {"] # [doc = "          \"type\": \"string\","] # [doc = "          \"enum\": ["] # [doc = "            \"light\","] # [doc = "            \"dark\","] # [doc = "            \"system\""] # [doc = "          ]"] # [doc = "        },"] # [doc = "        \"notificationsEnabled\": {"] # [doc = "          \"type\": \"boolean\""] # [doc = "        }"] # [doc = "      },"] # [doc = "      \"additionalProperties\": false"] # [doc = "    },"] # [doc = "    \"user\": {"] # [doc = "      \"type\": \"object\","] # [doc = "      \"required\": ["] # [doc = "        \"id\","] # [doc = "        \"name\""] # [doc = "      ],"] # [doc = "      \"properties\": {"] # [doc = "        \"id\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        \"name\": {"] # [doc = "          \"type\": \"string\""] # [doc = "        }"] # [doc = "      },"] # [doc = "      \"additionalProperties\": false"] # [doc = "    }"] # [doc = "  },"] # [doc = "  \"additionalProperties\": false"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (deny_unknown_fields)] pub struct AppState { pub config : AppStateConfig , pub user : AppStateUser , } impl :: std :: convert :: From < & AppState > for AppState { fn from (value : & AppState) -> Self { value . clone () } } impl AppState { pub fn builder () -> builder :: AppState { Default :: default () } } # [doc = "`AppStateConfig`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"notificationsEnabled\","] # [doc = "    \"theme\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"theme\": {"] # [doc = "      \"type\": \"string\","] # [doc = "      \"enum\": ["] # [doc = "        \"light\","] # [doc = "        \"dark\","] # [doc = "        \"system\""] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"notificationsEnabled\": {"] # [doc = "      \"type\": \"boolean\""] # [doc = "    }"] # [doc = "  },"] # [doc = "  \"additionalProperties\": false"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (deny_unknown_fields)] pub struct AppStateConfig { # [serde (rename = "notificationsEnabled")] pub notifications_enabled : bool , pub theme : AppStateConfigTheme , } impl :: std :: convert :: From < & AppStateConfig > for AppStateConfig { fn from (value : & AppStateConfig) -> Self { value . clone () } } impl AppStateConfig { pub fn builder () -> builder :: AppStateConfig { Default :: default () } } # [doc = "`AppStateConfigTheme`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"string\","] # [doc = "  \"enum\": ["] # [doc = "    \"light\","] # [doc = "    \"dark\","] # [doc = "    \"system\""] # [doc = "  ]"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] pub enum AppStateConfigTheme { # [serde (rename = "light")] Light , # [serde (rename = "dark")] Dark , # [serde (rename = "system")] System , } impl :: std :: convert :: From < & Self > for AppStateConfigTheme { fn from (value : & AppStateConfigTheme) -> Self { value . clone () } } impl :: std :: fmt :: Display for AppStateConfigTheme { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { match * self { Self :: Light => f . write_str ("light") , Self :: Dark => f . write_str ("dark") , Self :: System => f . write_str ("system") , } } } impl :: std :: str :: FromStr for AppStateConfigTheme { type Err = self :: error :: ConversionError ; fn from_str (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { match value { "light" => Ok (Self :: Light) , "dark" => Ok (Self :: Dark) , "system" => Ok (Self :: System) , _ => Err ("invalid value" . into ()) , } } } impl :: std :: convert :: TryFrom < & str > for AppStateConfigTheme { type Error = self :: error :: ConversionError ; fn try_from (value : & str) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < & :: std :: string :: String > for AppStateConfigTheme { type Error = self :: error :: ConversionError ; fn try_from (value : & :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } impl :: std :: convert :: TryFrom < :: std :: string :: String > for AppStateConfigTheme { type Error = self :: error :: ConversionError ; fn try_from (value : :: std :: string :: String) -> :: std :: result :: Result < Self , self :: error :: ConversionError > { value . parse () } } # [doc = "`AppStateUser`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"id\","] # [doc = "    \"name\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"name\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  },"] # [doc = "  \"additionalProperties\": false"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (deny_unknown_fields)] pub struct AppStateUser { pub id : :: std :: string :: String , pub name : :: std :: string :: String , } impl :: std :: convert :: From < & AppStateUser > for AppStateUser { fn from (value : & AppStateUser) -> Self { value . clone () } } impl AppStateUser { pub fn builder () -> builder :: AppStateUser { Default :: default () } } # [doc = "`OnChangeParams`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"title\": \"OnChangeParams\","] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"new_state\","] # [doc = "    \"state_id\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"state_id\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"new_state\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    }"] # [doc = "  },"] # [doc = "  \"additionalProperties\": false"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (deny_unknown_fields)] pub struct OnChangeParams { pub new_state : :: std :: string :: String , pub state_id : :: std :: string :: String , } impl :: std :: convert :: From < & OnChangeParams > for OnChangeParams { fn from (value : & OnChangeParams) -> Self { value . clone () } } impl OnChangeParams { pub fn builder () -> builder :: OnChangeParams { Default :: default () } } # [doc = "`OnChangeResponse`"] # [doc = r""] # [doc = r" <details><summary>JSON schema</summary>"] # [doc = r""] # [doc = r" ```json"] # [doc = "{"] # [doc = "  \"title\": \"OnChangeResponse\","] # [doc = "  \"type\": \"object\","] # [doc = "  \"required\": ["] # [doc = "    \"data\","] # [doc = "    \"error\","] # [doc = "    \"errorCode\""] # [doc = "  ],"] # [doc = "  \"properties\": {"] # [doc = "    \"data\": {"] # [doc = "      \"type\": \"string\""] # [doc = "    },"] # [doc = "    \"error\": {"] # [doc = "      \"anyOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"string\""] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"null\""] # [doc = "        }"] # [doc = "      ]"] # [doc = "    },"] # [doc = "    \"errorCode\": {"] # [doc = "      \"anyOf\": ["] # [doc = "        {"] # [doc = "          \"type\": \"number\""] # [doc = "        },"] # [doc = "        {"] # [doc = "          \"type\": \"null\""] # [doc = "        }"] # [doc = "      ]"] # [doc = "    }"] # [doc = "  },"] # [doc = "  \"additionalProperties\": false"] # [doc = "}"] # [doc = r" ```"] # [doc = r" </details>"] # [derive (:: serde :: Deserialize , :: serde :: Serialize , Clone , Debug)] # [serde (deny_unknown_fields)] pub struct OnChangeResponse { pub data : :: std :: string :: String , pub error : :: std :: option :: Option < :: std :: string :: String > , # [serde (rename = "errorCode")] pub error_code : :: std :: option :: Option < f64 > , } impl :: std :: convert :: From < & OnChangeResponse > for OnChangeResponse { fn from (value : & OnChangeResponse) -> Self { value . clone () } } impl OnChangeResponse { pub fn builder () -> builder :: OnChangeResponse { Default :: default () } } # [doc = r" Types for composing complex structures."] pub mod builder { # [derive (Clone , Debug)] pub struct AppState { config : :: std :: result :: Result < super :: AppStateConfig , :: std :: string :: String > , user : :: std :: result :: Result < super :: AppStateUser , :: std :: string :: String > , } impl :: std :: default :: Default for AppState { fn default () -> Self { Self { config : Err ("no value supplied for config" . to_string ()) , user : Err ("no value supplied for user" . to_string ()) , } } } impl AppState { pub fn config < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: AppStateConfig > , T :: Error : :: std :: fmt :: Display , { self . config = value . try_into () . map_err (| e | format ! ("error converting supplied value for config: {}" , e)) ; self } pub fn user < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: AppStateUser > , T :: Error : :: std :: fmt :: Display , { self . user = value . try_into () . map_err (| e | format ! ("error converting supplied value for user: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < AppState > for super :: AppState { type Error = super :: error :: ConversionError ; fn try_from (value : AppState) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { config : value . config ? , user : value . user ? , }) } } impl :: std :: convert :: From < super :: AppState > for AppState { fn from (value : super :: AppState) -> Self { Self { config : Ok (value . config) , user : Ok (value . user) , } } } # [derive (Clone , Debug)] pub struct AppStateConfig { notifications_enabled : :: std :: result :: Result < bool , :: std :: string :: String > , theme : :: std :: result :: Result < super :: AppStateConfigTheme , :: std :: string :: String > , } impl :: std :: default :: Default for AppStateConfig { fn default () -> Self { Self { notifications_enabled : Err ("no value supplied for notifications_enabled" . to_string ()) , theme : Err ("no value supplied for theme" . to_string ()) , } } } impl AppStateConfig { pub fn notifications_enabled < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < bool > , T :: Error : :: std :: fmt :: Display , { self . notifications_enabled = value . try_into () . map_err (| e | format ! ("error converting supplied value for notifications_enabled: {}" , e)) ; self } pub fn theme < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < super :: AppStateConfigTheme > , T :: Error : :: std :: fmt :: Display , { self . theme = value . try_into () . map_err (| e | format ! ("error converting supplied value for theme: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < AppStateConfig > for super :: AppStateConfig { type Error = super :: error :: ConversionError ; fn try_from (value : AppStateConfig) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { notifications_enabled : value . notifications_enabled ? , theme : value . theme ? , }) } } impl :: std :: convert :: From < super :: AppStateConfig > for AppStateConfig { fn from (value : super :: AppStateConfig) -> Self { Self { notifications_enabled : Ok (value . notifications_enabled) , theme : Ok (value . theme) , } } } # [derive (Clone , Debug)] pub struct AppStateUser { id : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , name : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for AppStateUser { fn default () -> Self { Self { id : Err ("no value supplied for id" . to_string ()) , name : Err ("no value supplied for name" . to_string ()) , } } } impl AppStateUser { pub fn id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . id = value . try_into () . map_err (| e | format ! ("error converting supplied value for id: {}" , e)) ; self } pub fn name < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . name = value . try_into () . map_err (| e | format ! ("error converting supplied value for name: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < AppStateUser > for super :: AppStateUser { type Error = super :: error :: ConversionError ; fn try_from (value : AppStateUser) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { id : value . id ? , name : value . name ? , }) } } impl :: std :: convert :: From < super :: AppStateUser > for AppStateUser { fn from (value : super :: AppStateUser) -> Self { Self { id : Ok (value . id) , name : Ok (value . name) , } } } # [derive (Clone , Debug)] pub struct OnChangeParams { new_state : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , state_id : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , } impl :: std :: default :: Default for OnChangeParams { fn default () -> Self { Self { new_state : Err ("no value supplied for new_state" . to_string ()) , state_id : Err ("no value supplied for state_id" . to_string ()) , } } } impl OnChangeParams { pub fn new_state < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . new_state = value . try_into () . map_err (| e | format ! ("error converting supplied value for new_state: {}" , e)) ; self } pub fn state_id < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . state_id = value . try_into () . map_err (| e | format ! ("error converting supplied value for state_id: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < OnChangeParams > for super :: OnChangeParams { type Error = super :: error :: ConversionError ; fn try_from (value : OnChangeParams) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { new_state : value . new_state ? , state_id : value . state_id ? , }) } } impl :: std :: convert :: From < super :: OnChangeParams > for OnChangeParams { fn from (value : super :: OnChangeParams) -> Self { Self { new_state : Ok (value . new_state) , state_id : Ok (value . state_id) , } } } # [derive (Clone , Debug)] pub struct OnChangeResponse { data : :: std :: result :: Result < :: std :: string :: String , :: std :: string :: String > , error : :: std :: result :: Result < :: std :: option :: Option < :: std :: string :: String > , :: std :: string :: String > , error_code : :: std :: result :: Result < :: std :: option :: Option < f64 > , :: std :: string :: String > , } impl :: std :: default :: Default for OnChangeResponse { fn default () -> Self { Self { data : Err ("no value supplied for data" . to_string ()) , error : Err ("no value supplied for error" . to_string ()) , error_code : Err ("no value supplied for error_code" . to_string ()) , } } } impl OnChangeResponse { pub fn data < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: string :: String > , T :: Error : :: std :: fmt :: Display , { self . data = value . try_into () . map_err (| e | format ! ("error converting supplied value for data: {}" , e)) ; self } pub fn error < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < :: std :: string :: String > > , T :: Error : :: std :: fmt :: Display , { self . error = value . try_into () . map_err (| e | format ! ("error converting supplied value for error: {}" , e)) ; self } pub fn error_code < T > (mut self , value : T) -> Self where T : :: std :: convert :: TryInto < :: std :: option :: Option < f64 > > , T :: Error : :: std :: fmt :: Display , { self . error_code = value . try_into () . map_err (| e | format ! ("error converting supplied value for error_code: {}" , e)) ; self } } impl :: std :: convert :: TryFrom < OnChangeResponse > for super :: OnChangeResponse { type Error = super :: error :: ConversionError ; fn try_from (value : OnChangeResponse) -> :: std :: result :: Result < Self , super :: error :: ConversionError > { Ok (Self { data : value . data ? , error : value . error ? , error_code : value . error_code ? , }) } } impl :: std :: convert :: From < super :: OnChangeResponse > for OnChangeResponse { fn from (value : super :: OnChangeResponse) -> Self { Self { data : Ok (value . data) , error : Ok (value . error) , error_code : Ok (value . error_code) , } } } }